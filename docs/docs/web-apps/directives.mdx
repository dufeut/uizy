---
sidebar_position: 5
sidebar_label: Directives
---

# Directives

Create custom attributes for `<ui-box>` elements with reusable logic.

## Overview

Directives are custom attributes that extend `<ui-box>` functionality. They receive the element and a context object with utilities for reactive effects and cleanup.

```javascript
// Register a directive
uizy.directive("highlight", (el, { value }) => {
    el.style.backgroundColor = value || "yellow";
});

// Use it
// <ui-box :highlight="red">Highlighted text</ui-box>
// or
// <ui-box u-highlight="red">Highlighted text</ui-box>
```

## Syntax

Directives support two prefix styles:

| Prefix | Example | Description |
|--------|---------|-------------|
| `:` | `:foo:arg="value"` | Short syntax (Vue-like) |
| `u-` | `u-foo:arg="value"` | Explicit syntax |

Both are equivalent and can be mixed.

## Registration

### Via `start()`

```javascript
uizy.start({
    directives: {
        // Simple directive (just element)
        uppercase: (el) => {
            el.style.textTransform = "uppercase";
        },

        // Full directive with context
        color: (el, { value }) => {
            el.style.color = value;
        },

        // Reactive directive
        bind: (el, { value, effect }) => {
            effect(() => {
                const store = uizy.$(value, { raw: true });
                return store?.subscribe((v) => {
                    el.textContent = String(v);
                });
            });
        },
    },
});
```

### Via `uizy.directive()`

```javascript
uizy.directive("tooltip", (el, { value, modifiers }) => {
    const position = modifiers.includes("top") ? "top" : "bottom";
    // Setup tooltip logic...
});
```

## Directive Context

The second argument to directive handlers is a context object:

```javascript
uizy.directive("example", (el, ctx) => {
    // ctx.value      - The attribute value (from first binding)
    // ctx.modifiers  - Array of all args from bindings
    // ctx.expression - The raw expression string
    // ctx.bindings   - All bindings for this directive
    // ctx.effect     - Register a reactive effect (auto-cleaned)
    // ctx.cleanup    - Register a cleanup function
});
```

### `value`

The attribute value as a string (from the first binding):

```html
<ui-box :example="hello world"></ui-box>
```

```javascript
uizy.directive("example", (el, { value }) => {
    console.log(value); // "hello world"
});
```

### `modifiers`

When using multiple bindings, all `arg` values are collected into `modifiers`:

```html
<ui-box :tooltip:top :tooltip:arrow="Help text"></ui-box>
```

```javascript
uizy.directive("tooltip", (el, { value, modifiers }) => {
    console.log(modifiers); // ["top", "arrow"]
    console.log(value);     // "" (from first binding)
});
```

### `bindings`

For advanced use cases, access all bindings with their individual values:

```html
<ui-box u-config:theme="dark" u-config:size="lg" u-config:animate></ui-box>
```

```javascript
uizy.directive("config", (el, { bindings }) => {
    console.log(bindings);
    // [
    //   { arg: "theme", value: "dark" },
    //   { arg: "size", value: "lg" },
    //   { arg: "animate", value: "" }
    // ]

    // Convert to object
    const config = Object.fromEntries(
        bindings.map(b => [b.arg, b.value || true])
    );
    console.log(config); // { theme: "dark", size: "lg", animate: true }
});
```

### `effect`

Register a reactive effect that returns an optional cleanup function:

```javascript
uizy.directive("autosize", (el, { effect }) => {
    effect(() => {
        const resize = () => {
            el.style.height = "auto";
            el.style.height = el.scrollHeight + "px";
        };

        el.addEventListener("input", resize);

        // Return cleanup function
        return () => el.removeEventListener("input", resize);
    });
});
```

### `cleanup`

Register cleanup functions directly:

```javascript
uizy.directive("interval", (el, { value, cleanup }) => {
    const id = setInterval(() => {
        el.textContent = new Date().toLocaleTimeString();
    }, parseInt(value) || 1000);

    cleanup(() => clearInterval(id));
});
```

## Examples

### Focus Directive

```javascript
uizy.directive("focus", (el) => {
    el.focus();
});
```

```html
<ui-box :focus>Auto-focused element</ui-box>
```

### Click Outside

```javascript
uizy.directive("click-outside", (el, { value, cleanup }) => {
    const handler = (event) => {
        if (!el.contains(event.target)) {
            // Execute the expression
            new Function(value).call(el);
        }
    };

    document.addEventListener("click", handler);
    cleanup(() => document.removeEventListener("click", handler));
});
```

```html
<ui-box :click-outside="console.log('clicked outside')">
    Click outside me
</ui-box>
```

### Lazy Load Images

```javascript
uizy.directive("lazy", (el, { value, cleanup }) => {
    const img = el.querySelector("img") || el;

    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                img.src = value;
                observer.disconnect();
            }
        });
    });

    observer.observe(el);
    cleanup(() => observer.disconnect());
});
```

```html
<ui-box :lazy="/images/large-photo.jpg">
    <img src="/images/placeholder.jpg" alt="Photo" />
</ui-box>
```

### Reactive Store Binding

```javascript
uizy.directive("model", (el, { value, effect }) => {
    const input = el.querySelector("input") || el;

    effect(() => {
        const store = uizy.$(value, { raw: true });
        if (!store) return;

        // Two-way binding
        const unsubscribe = store.subscribe((v) => {
            if (input.value !== v) input.value = v;
        });

        const onInput = () => store.set(input.value);
        input.addEventListener("input", onInput);

        return () => {
            unsubscribe();
            input.removeEventListener("input", onInput);
        };
    });
});
```

```html
<ui-box :model="form.username">
    <input type="text" />
</ui-box>
```

### Conditional Visibility

```javascript
uizy.directive("show", (el, { value, effect }) => {
    effect(() => {
        const store = uizy.$(value, { raw: true });
        if (!store) {
            el.style.display = value ? "" : "none";
            return;
        }

        return store.subscribe((v) => {
            el.style.display = v ? "" : "none";
        });
    });
});
```

```html
<ui-box :show="ui.modalOpen">Modal content</ui-box>
```

### Multi-Binding Configuration

```javascript
uizy.directive("style", (el, { bindings }) => {
    for (const { arg, value } of bindings) {
        if (arg && value) {
            el.style[arg] = value;
        }
    }
});
```

```html
<ui-box u-style:color="red" u-style:fontSize="20px" u-style:fontWeight="bold">
    Styled text
</ui-box>
```

## API Reference

### `uizy.directive(name, handler)`

Register a custom directive.

| Parameter | Type | Description |
|-----------|------|-------------|
| `name` | `string` | Directive name (used as `:name` or `u-name` attribute) |
| `handler` | `DirectiveHandler` | Handler function |

### `uizy.directives`

Access the directives registry:

| Method | Description |
|--------|-------------|
| `.add(name, handler)` | Register a directive |
| `.addAll(directives)` | Register multiple directives |
| `.get(name)` | Get a directive handler |
| `.has(name)` | Check if directive exists |
| `.names()` | List all directive names |
| `.clear()` | Remove all directives |

### DirectiveHandler

```typescript
type DirectiveHandler = (el: HTMLElement, ctx: DirectiveContext) => void;
```

### DirectiveBinding

```typescript
interface DirectiveBinding {
    value: string;  // The attribute value
    arg: string;    // The first modifier (e.g., "top" from :foo:top)
}
```

### DirectiveContext

```typescript
interface DirectiveContext {
    value: string;              // Value from first binding
    modifiers: string[];        // All args collected from bindings
    expression: string;         // Raw expression string
    bindings: DirectiveBinding[]; // All bindings for this directive
    effect: (fn: () => (() => void) | void) => void;
    cleanup: (fn: () => void) => void;
}
```

## Best Practices

1. **Keep directives focused** - Each directive should do one thing well
2. **Always cleanup** - Use `cleanup()` or return cleanup from `effect()` to prevent memory leaks
3. **Use bindings for config** - For multiple options, use `u-foo:opt1="val" u-foo:opt2="val"` pattern
4. **Handle missing values gracefully** - Check if `value` exists before using it
5. **Document your directives** - Add comments explaining what each directive does
